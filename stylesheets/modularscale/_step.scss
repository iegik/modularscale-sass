@use 'sass:list';
@use 'sass:map';
@use 'sass:math';
@use 'sass:meta';

@use 'constants' as *;
@use 'settings' as *;
@use 'sort' as *;
@use 'ratio-by-target' as *;

$_settings: () !default;

@function step(
  $v: 0,
  $respond: null,
  $base: null,
  $ratio: null,
  $thread: null,
  $settings: $_settings
) {
  // Parse settings
  @if ($respond) {
    $thread: $respond;
  }

  @if meta.type-of($ratio) == 'string' {
    @if map.has-key($ratios, $ratio) {
      $ratio: map.get($ratios, $ratio);
    } @else {
      @error '#{$ratio} isn\'t a valid ratio';
    }
  }

  $settings: settings($base, $ratio, $thread, $settings);
  $base: list.nth($settings, 1);
  $ratio: list.nth($settings, 2);
  $base-length: list.length($base);
  $bases: ();

  // Render target values from settings.
  @if type-of($ratio) == 'string' or type-of($ratio) == 'list' {
    $ratio: radio-target($ratio, $base);
  }

  // Fast calc if not multi stranded
  @if ($base-length == 1) {
    // if the step provided is actually a target and has the same unit as the base,
    // we can figured the closest integer step on the current scale to be used.
    // It's for the cases when the designer provided all values as pixels and
    // not respecting the modular scale to the "number", but getting close.
    // Designers don't like float numbers.
    @if (math.unit($v) == math.unit($base) or math.unit($v) == 'px') {
      // convert target pixels to the unit used on $base
      @if (not math.compatible($v, $base)) {
        @if (math.unit($v) != 'px') {
          @error 'To match incompatible units, the target one needs to be `px`, as we use 16px as root size. Target provided: #{$v}.';
        }

        @if (math.unit($base) == 'rem') {
          $v: math.div($v, 16px) * 1rem;
        } @else if (math.unit($base) == 'em') {
          $v: math.div($v, 16px) * 1em;
        } @else if (math.unit($base) == '%') {
          $v: math.div($v, 16px * math.div($base, 100%)) * $base;
        } @else {
          @error '#{$v} and #{$base} don\'t have units that can be converted using browser root size';
        }
      }

      $v: math.log(math.div($v, $base), $ratio);
      $v: math.round($v);
    }

    @return math.pow($ratio, $v) * $base;
  } @else {
    $bases: list.nth($base, 1);

    @for $i from 2 through $base-length {
      $new-base: list.nth($base, $i);

      @while ($new-base > ($ratio * list.nth($base, 1))) {
        $new-base: math.div($new-base, $ratio);
      }

      @while ($new-base < list.nth($base, 1)) {
        $new-base: ($new-base * $ratio);
      }
      $bases: list.append($bases, $new-base);
    }

    $bases: sort($bases);
  }

  // Find step to use in calculation
  $step: math.floor(math.div($v, $base-length));

  // Find base to use in calculation
  $base: math.round((math.div($v, $base-length) - $step) * $base-length) + 1;

  @return math.pow($ratio, $step) * list.nth($bases, $base);
}
