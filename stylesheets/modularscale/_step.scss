@use "sass:list";
@use 'sass:math';

@use 'settings' as *;
@use 'sort' as *;
@use 'target' as *;

$settings: $settings !default;

@function step(
  $v: 0,
  $respond: false,
  $base: false,
  $ratio: false,
  $thread: false,
  $settings: $settings
) {
  // Parse settings
  @if ($respond) {
    $thread: $respond;
  }
  $settings: settings($base, $ratio, $thread, $settings);
  $base: list.nth($settings, 1);
  $ratio: list.nth($settings, 2);
  $base-length: list.length($base);
  $bases: ();

  // if the step provided is actually a target and has the same unit as the base,
  // we can figured the closest integer step on the current scale to be used.
  // it's for the cases when the designer provided all values as pixels and not respecting
  // the modular scale to the "number", but getting close.
  // Designers don't like float numbers.
  @if (math.unit($v) == math.unit($base)) {
    $v: math.log(math.div($v, $base), $ratio);
    $v: math.round($v);
  }

  // Render target values from settings.
  @if math.unit($ratio) != "" {
    $ratio: target($ratio, $base);
  }

  // Fast calc if not multi stranded
  @if ($base-length == 1) {
    @return math.pow($ratio, $v) * $base;
  } @else {
    $unit: math.unit(list.nth($base, 1));
    $bases: list.nth($base, 1);
    @for $i from 2 through $base-length {
      $new-base: list.nth($base, $i);
      @while ($new-base > ($ratio * list.nth($base, 1))) {
        $new-base: math.div($new-base, $ratio);
      }
      @while ($new-base < list.nth($base, 1)) {
        $new-base: ($new-base * $ratio);
      }
      $bases: list.append($bases, $new-base);
    }

    $bases: sort($bases);
  }

  // Find step to use in calculation
  $step: math.floor(math.div($v, $base-length));

  // Find base to use in calculation
  $base: math.round((math.div($v, $base-length) - $step) * $base-length) + 1;

  @return math.pow($ratio, $step) * list.nth($bases, $base);
}
